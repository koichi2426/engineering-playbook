# 6. クリーンアーキテクチャ (Clean Architecture)

このドキュメントは、私たちが採用するクリーンアーキテクチャの「4つの層」と、各層に登場する「概念（部品）」の責務を定義します。

---

## 1. ドメイン層 (Domain Layer)

**責務:** アプリケーションの核となる、純粋なビジネスルールを定義する層。他のどの層にも依存してはいけない。

### 登場する概念

#### 1a. エンティティ (Entity)
* **定義:** 一意なIDを持ち、時間経過と共に状態が変わるオブジェクト。
* **例:** `User`, `Article`, `Order`

#### 1b. 値オブジェクト (Value Object)
* **定義:** 属性そのものが「値」としての意味を持つ、不変（Immutable）なオブジェクト。
* **例:** `EmailAddress`（文字列だが形式チェックを持つ）, `Money`（金額と通貨）

#### 1c. ドメインサービス (Domain Service)
* **定義:** 特定のエンティティや値オブジェクトの責務とは言えない、ドメイン固有のロジック。
* **例:** 「2つの`Order`（エンティティ）をマージする」ロジック。

#### 1d. リポジトリ・インターフェース (Repository Interface)
* **定義:** ドメインオブジェクトを永続化するための「操作」のみを定義したインターフェース（`trait` や `abstract class`）。
* **責務:** 「どうやって保存するか（=SQL）」は知らず、「保存する」「IDで探す」といった**契約**だけを定義する。

---

## 2. ユースケース層 (Usecase Layer)

**責務:** アプリケーション固有のロジック（＝ユースケース）を実行する層。ドメイン層をオーケストレーション（指揮）する。

### 登場する概念

#### 2a. ユースケース (Usecase / Interactor)
* **定義:** 「ユーザーを作成する」「記事を投稿する」といった、一つの完結した操作フロー。
* **責務:**
    1.  `コントローラー`から指示（DTO）を受ける。
    2.  `リポジトリ・インターフェース`を使ってドメインオブジェクト（`エンティティ`など）を取得・保存する。
    3.  ドメインのロジック（`エンティティ`や`ドメインサービス`）を呼び出す。
    4.  結果を`プレゼンター`に返す。

---

## 3. アダプタ層 (Adapter Layer)

**責務:** ユースケース層とインフラ層の間の「翻訳者」。外側の都合（HTTP, SQL）と、内側のロジック（ユースケース）を変換する。

### 登場する概念

#### 3a. コントローラー (Controller)
* **定義:** 外部からの入力を受け取る部品。
* **責務:** HTTPリクエスト（やgRPCリクエストなど）を受け取り、ユースケースが理解できる形式（DTOなど）に変換して、ユースケースを呼び出す。

#### 3b. プレゼンター (Presenter)
* **定義:** 外部への出力を作成する部品。
* **責務:** ユースケースからの出力（ドメインオブジェクトなど）を受け取り、HTTPレスポンス（JSONなど）に変換する。

#### 3c. リポジトリ実装 (Repository Implementation)
* **定義:** `ドメイン層`で定義された`リポジトリ・インターフェース`の、具体的な実装。
* **責務:** `インフラ層`のDBクライアント（例: ORM）を使い、「保存する」というインターフェースに対して「実際にSQLを実行する」コードを書く。

---

## 4. インフラストラクチャ層 (Infrastructure Layer)

**責務:** すべての「外部」に関わる、具体的な技術。

### 登場する概念

#### 4a. フレームワーク (Frameworks)
* **定義:** Webフレームワーク（FastAPI, Next.js）、gRPCサーバーなど。
* **責務:** `コントローラー`を起動し、リクエストをルーティングする。

#### 4b. 永続化 (Persistence)
* **定義:** データベース（PostgreSQL, MySQL）や、ORM（Prisma, SQLAlchemy）など。
* **責務:** `リポジトリ実装`から呼び出され、実際にデータを読み書きする。